[
  {
    "objectID": "Chapters/12-file-op.html",
    "href": "Chapters/12-file-op.html",
    "title": "13  Filesystem and Input/Output (IO)",
    "section": "",
    "text": "13.1 Input/Output basics\nIn this chapter we are going to discuss how to use the cross-platform structs and functions from the Zig Standard Library that can execute filesystem operations. Most of these functions and structs comes from the std.fs module.\nWe are also going to talk about Input/Output (also known as IO) operations in Zig. Most of these operations are made by using the structs and functions from std.io module, which defines file descriptors for the standard channels of your system (stdout and stdin), and also, functions to create and use I/O streams.\nIf you have some experience in a high-level language, you have certainly used these input and output functionalities before in this language. In other words, you certainly have been in a situation where you needed to sent some output to the user, or, to receive an input from the user.\nFor example, in Python we can receive some input from the user by using the input() built-in function. But we can also print (or “show”) some output to the user by using the print() built-in function. So yes, if you have programmed before in Python, you certainly have used these functions once before.\nBut do you know how these functions relate back to your operating system (OS)? How exactly they are interacting with the resources of your OS to receive or sent some input/output. In essence, these input/output functions from high-level languages are just abstractions over the standard output and standard input channels of your operating system.\nThis means that we receive an input, or send some output, through the operating system. It’s the OS that makes the bridge between the user and your program. Your program does not have a direct access to the user. It’s the OS that intermediates every message exchanged between your program and the user.\nThe standard output and standard input channels of your OS are commonly known as the stdout and stdin channels of your OS, respectively. In some contexts, they are also called the standard output device and the standard input device. As the name suggests, the standard output is the channel through which output flows, while the standard input is the channel in which input flows.\nFurthermore, OS’s also normally create a dedicated channel for exchanging error messages, which is known as the standard error channel, or, the stderr channel. This is the channel to which error and warning messages are usually sent to. These are the messages that are normally displayed in red-like or orange-like colors into your terminal.\nNormally, every OS (e.g. Windows, macOS, Linux, etc.) creates a dedicated and separate set of standard output, standard error and standard input channels for every single program (or process) that runs in your computer. This means that every program you write have a dedicated stdin, stderr and stdout that are separate from the stdin, stderr and stdout of other programs and processes that are currently running.\nThis is a behaviour from your OS. This does not come from the programming language that you are using. Because as I sad earlier, input and output in programming languages, especially in high-level ones, are just a simple abstraction over the stdin, stderr and stdout from your current OS. That is, your OS is the intermediary between every input/output operation made in your program, regardless of the programming language that you are using.",
    "crumbs": [
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Filesystem and Input/Output (IO)</span>"
    ]
  },
  {
    "objectID": "Chapters/12-file-op.html#sec-io-basics",
    "href": "Chapters/12-file-op.html#sec-io-basics",
    "title": "13  Filesystem and Input/Output (IO)",
    "section": "",
    "text": "13.1.1 The writer and reader pattern\nIn Zig, there is a pattern around input/output (IO). I (the author of this book) don’t know if there is an official name for this pattern. But here, in this book, I will call it the “writer and reader pattern”. In essence, every IO operation in Zig is made through either a Reader or a Writer object1.\nThese two data types come from the std.io module of the Zig Standard Library. As their names suggests, a Reader is an object that offers tools to read data from “something” (or “somewhere”), while a Writer offers tools to write data into this “something”. This “something” might be different things: like a file that exists in your filesystem; or, it might be a network socket in your system2; or, a continuous stream of data, like a standard input device from your system, that might be constantly receiving new data from users, or, as another example, a live chat in a game that is constantly receiving and displaying new messages from the players of the game.\nSo, if you want to read data from something, or somewhere, it means that you need to use a Reader object. But if you need instead, to write data into this “something”, then, you need to use a Writer object instead. Both of these objects are normally created from a file descriptor object. More specifically, through the writer() and reader() methods of this file descriptor object. If you are not familiar with this type of object, go to the next section.\nEvery Writer object has methods like print(), which allows you to write/send a formatted string (i.e., this formatted string is like a f string in Python, or, similar to the printf() C function) into the “something” (file, socket, stream, etc.) that you are using. It also has a writeAll() method, which allows you to write a string, or, an array of bytes into the “something”.\nLikewise, every Reader object have methods like readSliceAll(), which allows you to read the data from the “something” (file, socket, stream, etc.) until it fills a particular array (i.e., a “buffer”) object. In other words, if you provide an array object of 300 u8 values to readSliceAll(), then, this method attempts to read 300 bytes of data from the “something”, and it stores them into the array object that you have provided.\nAnother useful method is takeDelimiterExclusive(). In this method, you specify a “delimiter character”. The idea is that this function will attempt to read as many bytes of data as possible from the “something” until it finds the “delimiter character” that you have specified, and, it returns a slice with the data to you.\nThis is just a quick description of the methods present in these types of objects. But I recommend you to read the official docs, both for Writer3 and Reader4. I also think it’s a good idea to read the source code of the modules in the Zig Standard Library that defines the methods present in these objects, which are the Reader.zig5 and Writer.zig6.\n\n\n13.1.2 Introducing file descriptors\nA “file descriptor” object is a core component behind every IO operation that is made in any operating system (OS). Such object is an identifier for a particular input/output (IO) resource from your OS (Wikipedia 2024). It describes and identifies this particular resource. An IO resource might be:\n\nan existing file in your filesystem.\nan existing network socket.\nother types of stream channels.\na pipeline (or just “pipe”) in your terminal7.\n\nFrom the bullet points listed above, we know that although the term “file” is present, a “file descriptor” might describe something more than just a file. This concept of a “file descriptor” comes from the Portable Operating System Interface (POSIX) API, which is a set of standards that guide how operating systems across the world should be implemented, to maintain compatibility between them.\nA file descriptor not only identifies the input/output resource that you are using to receive or send some data, but it also describes where this resource is, and also, which IO mode this resource is currently using. For example, this IO resource might be using only the “read” IO mode, which means that this resource is open to “read operations”, while “write operations” are not authorized. These IO modes are essentially the modes that you provide to the argument mode from the fopen() C function, and also, from the open() Python built-in function.\nIn C, a “file descriptor” is a FILE pointer, but, in Zig, a file descriptor is a File object. This data type (File) is described in the std.fs module of the Zig Standard Library. We normally don’t create a File object directly in our Zig code. Instead, we normally get such object as result when we open an IO resource. In other words, we normally ask our OS to open a particular IO resource for us, and, if the OS do open successfully this IO resource, the OS normally handles back to us a file descriptor to this particular IO resource.\nSo you usually get a File object by using functions and methods from the Zig Standard Library that asks the OS to open some IO resource, like the openFile() method that opens a file in the filesystem. The net.Stream object that we have created in Section 7.4.1 is also a type of file descriptor object.\n\n\n13.1.3 The standard output\nYou already saw across this book, how can we access and use specifically the stdout in Zig to send some output to the user. For that, we use the File.stdout() function from the std.fs module. This function returns a file descriptor that describes the stdout channel of your current OS. Through this file descriptor object, we can read from or write stuff to the stdout of our program.\nAlthough we can read stuff recorded into the stdout channel, we normally only write to (or “print”) stuff into this channel. The reason is very similar to what we discussed at Section 7.4.3, when we were discussing what “reading from” versus “writing to” the connection object from our small HTTP Server project would mean.\nWhen we write stuff into a channel, we are essentially sending data to the other end of this channel. In contrast, when we read stuff from this channel, we are essentially reading the data that was sent through this channel. Since the stdout is a channel to send output to the user, the key verb here is send. We want to send something to someone, and, as consequence, we want to write something into some channel.\nThat is why, when we access File.stdout(), most of the times, we also use the writer() method from the stdout file descriptor, to get access to a writer object that we can use to write stuff into this stdout channel. As we described in Section 13.1.1, this writer() method returns a Writer object, and one of the main methods of this Writer object is the print() method that we have used extensively across this book to write (or “print”) a formatted string into the stdout channel.\nYou should also notice in the example below, that in order to instantiate this Writer object, we must provide a reference to a buffer object as input to the writer() method. In the example below, this buffer object is stdout_buffer. By providing such buffer, we transform the IO operations performed by the Writer object into “buffered IO operations”. We are going to talk more about “buffered IO” in Section 13.2, so, don’t worry too much about that for now.\n\nconst std = @import(\"std\");\nvar stdout_buffer: [1024]u8 = undefined;\nvar stdout_writer = std.fs.File.stdout().writer(&stdout_buffer);\nconst stdout = &stdout_writer.interface;\n\npub fn main() !void {\n    try stdout.writeAll(\n        \"This message was written into stdout.\\n\"\n    );\n}\n\nThis Writer object is like any other writer object that you would normally get from a file descriptor object. So, the same methods from a writer object that you would use while writing files to the filesystem for example, you could also use them here, from the file descriptor object of stdout, and vice-versa.\n\n\n13.1.4 The standard input\nYou can access the standard input (i.e., stdin) in Zig by using the File.stdin() function from the std.fs module. Like its brother (File.stdout()), this function also returns a file descriptor object that describes the stdin channel of your OS.\nBecause we want to receive some input from the user, the key verb here becomes receive, and, as consequence, we usually want to read data from the stdin channel, instead of writing data into it. So, we normally use the reader() method of the file descriptor object returned by File.stdin(), to get access to a Reader object that we can use to read data from stdin.\nIn the example below, we try to read the data from the stdin with the takeDelimiterExclusive() method (which will read all the data from the stdin until it hits a new line character - '\\n', in the stream), and save this data into the name object.\nYou should also notice that, like we did with the writer() method, we also need to provide a reference to a buffer object as input to the reader() method, when instantiating our Reader object. The reasons are exactly the same. This input buffer transforms the IO operations performed by the Reader object into “buffered IO operations”.\nIf you execute this program, you will notice that it stops the execution, ands start to wait indefinitely for some input from the user. In other words, you need to type your name into the terminal, and then, you press Enter to send your name to stdin. After you send your name to stdin, the program reads this input, and continues with the execution, by printing the given name to stdout. In the example below, I typed my name (Pedro) into the terminal, and then, pressed Enter.\n\nconst std = @import(\"std\");\nvar stdin_buffer: [1024]u8 = undefined;\nvar stdout_buffer: [1024]u8 = undefined;\nvar stdout_writer = std.fs.File.stdout().writer(&stdout_buffer);\nvar stdin_reader = std.fs.File.stdin().reader(&stdin_buffer);\nconst stdin = &stdin_reader.interface;\nconst stdout = &stdout_writer.interface;\n\npub fn main() !void {\n    try stdout.writeAll(\"Type your name\\n\");\n    try stdout.flush();\n\n    const name = try stdin.takeDelimiterExclusive('\\n');\n\n    try stdout.print(\"Your name is: {s}\\n\", .{name});\n    try stdout.flush();\n}\n\nType your name\nYour name is: Pedro\n\n\n13.1.5 The standard error\nThe standard error (a.k.a. the stderr) works exactly the same as stdout and stdin. You just call the File.stderr() function from the std.fs module, and you get the file descriptor to stderr. Ideally, you should write only error or warning messages to stderr, because this is the purpose of this channel.",
    "crumbs": [
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Filesystem and Input/Output (IO)</span>"
    ]
  },
  {
    "objectID": "Chapters/12-file-op.html#sec-buffered-io",
    "href": "Chapters/12-file-op.html#sec-buffered-io",
    "title": "13  Filesystem and Input/Output (IO)",
    "section": "13.2 Buffered IO",
    "text": "13.2 Buffered IO\nAs we described in Section 13.1, input/output (IO) operations are made directly by the operating system. It’s the OS that manages the IO resource that you want to use for your IO operations. The consequence of this fact is that IO operations are heavily based on system calls (i.e., calling the operating system directly).\nJust to be clear, there is nothing particularly wrong with system calls. We use them all the time on any serious codebase written in any low-level programming language. However, system calls are always orders of magnitude slower than many different types of operations.\nSo is perfectly fine to use a system call once in a while. But when these system calls are used often, you can clearly notice most of the time the loss of performance in your application. So, the good rule of thumb is to use a system call only when it’s needed, and also, only in infrequent situations, to reduce the number of system calls performed to a minimum.\n\n13.2.1 Understanding how buffered IO works\nBuffered IO is a strategy to achieve better performance. It’s used to reduce the number of system calls made by IO operations, and, as consequence, achieve a much higher performance. In Figure 13.1 and Figure 13.2 you can find two different diagrams which presents the difference between read operations performed in an unbuffered IO environment versus a buffered IO environment.\nTo give a better context to these diagrams, let’s suppose that we have a text file that contains the famous Lorem ipsum text8 in our filesystem. Let’s also suppose that these diagrams in Figure 13.1 and Figure 13.2 are showing the read operations that we are performing to read the Lorem ipsum text from this text file. The first thing you will notice when looking at these diagrams, is that in an unbuffered environment the read operations leads to many system calls. More precisely, in the diagram exposed in Figure 13.1 we get one system call per each byte that we read from the text file. On the other hand, in Figure 13.2 we have only one system call at the very beginning.\nWhen we use a buffered IO system, at the first read operation we perform, instead of sending one single byte directly to our program, the OS first sends a chunk of bytes from the file to a buffer object (i.e., an array). This chunk of bytes are cached/stored inside this buffer object.\nTherefore, from now on, for every new read operation that you perform, instead of making a new system call to ask for the next byte in the file to the OS, this read operation is redirected to the buffer object, that have this next byte already cached and ready to go.\n\n\n\n\n\n\nFigure 13.1: Unbuffered IO\n\n\n\n\n\n\n\n\n\nFigure 13.2: Buffered IO\n\n\n\nThis is the basic logic behind buffered IO systems. The size of the buffer object depends on multiple factors. But it’s usually equal to the size of a full page of memory (4096 bytes). If we follow this logic, then, the OS reads the first 4096 bytes of the file and caches it into the buffer object. As long as your program does not consume all of these 4096 bytes from the buffer, you will not create new system calls.\nHowever, as soon as you consume all of these 4096 bytes from the buffer, it means that there is no bytes left in the buffer. In this situation, a new system call is made to ask the OS to send the next 4096 bytes in the file, and once again, these bytes are cached into the buffer object, and the cycle starts once again.\n\n\n\n\n\n\nTip\n\n\n\nIn general, you should always use a buffered IO reader or a buffered IO writer object in your code. Because they deliver better performance to your IO operations.\n\n\n\n\n13.2.2 Using buffered IO in Zig\nPreviously, IO operations in Zig were not buffered by default. However, since the new IO interface introduced in Zig 0.15, the Reader and Writer interfaces take a buffer object as input when they are instantiated, like we demonstrated in Section 13.1.3. In other words, a buffer object must be provided to instantiate a Reader or Writer object in your code. And because of that, we have buffered IO operations by default on the most recent versions of Zig.\nIf you compare it with other languages, you will notice that Zig takes a slightly different approach in it’s “buffered IO strategy”. If we take C as an example, the IO operations made through a FILE pointer in C are buffered by default. However, in C, you don’t need to explicitly pass a buffer object when instantiating such FILE pointer, because this buffer object is created behind the scenes for you, and therefore, it becomes invisible to the programmer. While in Zig, you must manually create this buffer object yourself.\nSo, Zig not only choose to use buffered IO, but it also choose to give the programmer full control over the buffer used in such operations. You (as the programmer) can directly control the size of this buffer, and you can also directly control how this specific buffer object is allocated in your code (i.e. you can either allocate it in the stack, or, use an Allocator object to allocate it in the heap), which fits very well with the “no hidden allocations” mantra of Zig.\nThus, if you want to use buffered IO in Zig, just make sure to pass a reference to a buffer object as input to either the writer() or reader() methods to create a Writer or Reader object that performs buffered IO operations by default.",
    "crumbs": [
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Filesystem and Input/Output (IO)</span>"
    ]
  },
  {
    "objectID": "Chapters/12-file-op.html#filesystem-basics",
    "href": "Chapters/12-file-op.html#filesystem-basics",
    "title": "13  Filesystem and Input/Output (IO)",
    "section": "13.3 Filesystem basics",
    "text": "13.3 Filesystem basics\nNow that we have discussed the basics around Input/Output operations in Zig, we need to talk about the basics around filesystems, which is another core part of any operating system. Also, filesystems are related to input/output, because the files that we store and create in our computer are considered an IO resource, as we described in Section 13.1.2.\n\n13.3.1 The concept of current working directory (CWD)\nThe working directory is the folder on your computer where you are currently rooted at. In other words, it’s the folder that your program is currently looking at. Therefore, whenever you are executing a program, this program is always working with a specific folder on your computer. It’s always in this folder that the program will initially look for the files you require, and it’s also in this folder that the program will initially save all the files you ask it to save.\nThe working directory is determined by the folder from which you invoke your program in the terminal. In other words, if you are in the terminal of your OS, and you execute a binary file (i.e., a program) from this terminal, the folder to which your terminal is pointing at is the current working directory of your program that is being executed.\nIn Figure 13.3 we have an example of me executing a program from the terminal. We are executing the program outputted by the zig compiler by compiling the Zig module named hello.zig. The CWD in this case is the zig-book folder. In other words, while the hello.zig program is executing, it will be looking at the zig-book folder, and any file operation that we perform inside this program, will be using this zig-book folder as the “starting point”, or, as the “central focus”.\n\n\n\n\n\n\nFigure 13.3: Executing a program from the terminal\n\n\n\nJust because we are rooted inside a particular folder (in the case of Figure 13.3, the zig-book folder) of our computer, it doesn’t mean that we cannot access or write resources in other locations of our computer. The current working directory (CWD) mechanism just defines where your program will look first for the files you ask for. This does not prevent you from accessing files that are located elsewhere on your computer. However, to access any file that is in a folder other than your current working directory, you must provide a path to that file or folder.\n\n\n13.3.2 The concept of paths\nA path is essentially a location. It points to a location in your filesystem. We use paths to describe the location of files and folders in our computer. One important aspect about paths is that they are always written inside strings, i.e., they are always provided as text values.\nThere are two types of paths that you can provide to any program in any OS: a relative path, or an absolute path. Absolute paths are paths that start at the root of your filesystem, and go all the way to the file name or the specific folder that you are referring to. This type of path is called absolute, because it points to an unique and absolute location on your computer. That is, there is no other existing location on your computer that corresponds to this path. It’s an unique identifier.\nIn Windows, an absolute path is a path that starts with a hard disk identifier (e.g. C:/Users/pedro). On the other hand, absolute paths in Linux and macOS, are paths that start with a forward slash character (e.g. /usr/local/bin). Notice that a path is composed by “segments”. Each segment is connected to each other by a slash character (\\ or /). On Windows, the backward slash (\\) is normally used to connect the path segments. While on Linux and macOS, the forward slash (/) is the character used to connect path segments.\nA relative path is a path that start at the CWD. In other words, a relative path is “relative to the CWD”. The path used to access the hello.zig file in Figure 13.3 is an example of a relative path. This path is reproduced below. This path begins at the CWD, which in the context of Figure 13.3, is the zig-book folder, then, it goes to the ZigExamples folder, then, into zig-basics, then, to the hello.zig file.\nZigExamples/zig-basics/hello_world.zig\n\n\n13.3.3 Path wildcards\nWhen providing paths, especially relative paths, you have the option of using a wildcard. There are two commonly used wildcards in paths, which are “one period” (.) and “two periods” (..). In other words, these two specific characters have special meanings when used in paths, and can be used on any operating system (Mac, Windows, Linux, etc.). That is, they are “cross platform”.\nThe “one period” represents an alias for the current directory. This means that the relative paths \"./Course/Data/covid.csv\" and \"Course/Data/covid.csv\" are equivalent. On the other hand, the “two periods” refers to the previous directory. For example, the path \"Course/..\" is equivalent to the path \".\", that is, the current working directory.\nTherefore, the path \"Course/..\" refers to the folder before the Course folder. As another example, the path \"src/writexml/../xml.cpp\" refers to the file xml.cpp that is inside the folder before the writexml folder, which in this example is the src folder. Therefore, this path is equivalent to \"src/xml.cpp\".",
    "crumbs": [
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Filesystem and Input/Output (IO)</span>"
    ]
  },
  {
    "objectID": "Chapters/12-file-op.html#the-cwd-handler",
    "href": "Chapters/12-file-op.html#the-cwd-handler",
    "title": "13  Filesystem and Input/Output (IO)",
    "section": "13.4 The CWD handler",
    "text": "13.4 The CWD handler\nIn Zig, filesystem operations are usually made through a directory handler object. A directory handler in Zig is an object of type Dir, which is an object that describes a particular folder in the filesystem of our computer. You normally create a Dir object, by calling the std.fs.cwd() function. This function returns a Dir object that points to (or, that describes) the current working directory (CWD).\nThrough this Dir object, you can create new files, or modify, or read existing ones that are inside your CWD. In other words, a Dir object is the main entrypoint in Zig to perform multiple types of filesystem operations. In the example below, we are creating this Dir object, and storing it inside the cwd object. Although we are not using this object at this code example, we are going to use it a lot over the next examples.\n\nconst cwd = std.fs.cwd();\n_ = cwd;",
    "crumbs": [
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Filesystem and Input/Output (IO)</span>"
    ]
  },
  {
    "objectID": "Chapters/12-file-op.html#file-operations",
    "href": "Chapters/12-file-op.html#file-operations",
    "title": "13  Filesystem and Input/Output (IO)",
    "section": "13.5 File operations",
    "text": "13.5 File operations\n\n13.5.1 Creating files\nWe create new files by using the createFile() method from the Dir object. Just provide the name of the file that you want to create, and this function will do the necessary steps to create such file. You can also provide a relative path to this function, and it will create the file by following this path, which is relative to the CWD.\nThis function might return an error, so, you should use try, catch, or any of the other methods presented in Chapter 10 to handle the possible error. But if everything goes well, this createFile() method returns a file descriptor object (i.e., a File object) as result, through which you can add content to the file with the IO operations that I presented before.\nTake this code example below. In this example, we are creating a new text file named foo.txt. If the function createFile() succeeds, the object named file will contain a file descriptor object, which we can use to write (or add) new content to the file, like we do in this example, by using a buffered writer object to write a new line of text to the file.\nNow, a quick note, when we create a file descriptor object in C, by using a C function like fopen(), we must always close the file at the end of our program, or, as soon as we complete all operations that we wanted to perform on the file. In Zig, this is no different. So everytime we create a new file, this file remains “open”, waiting for some operation to be performed. As soon as we are done with it, we always have to close this file, to free the resources associated with it. In Zig, we do this by calling the method close() from the file descriptor object.\n\nconst cwd = std.fs.cwd();\nconst file = try cwd.createFile(\"foo.txt\", .{});\n// Don't forget to close the file at the end.\ndefer file.close();\n// Do things with the file ...\nvar fw = file.writer();\n_ = try fw.writeAll(\n    \"Writing this line to the file\\n\"\n);\n\nSo, in this example we not only have created a file into the filesystem, but we also wrote some data into this file, using the file descriptor object returned by createFile(). If the file that you are trying to create already exists in your filesystem, this createFile() call will overwrite the contents of the file, or, in other words, it will in erase all the contents of the existing file.\nIf you don’t want this to happen, meaning, that you don’t want to overwrite the contents of the existing file, but you want to write data to this file anyway (i.e., you want to append data to the file), you should use the openFile() method from the Dir object.\nAnother important aspect about createFile() is that this method creates a file that is not open to read operations by default. It means that you cannot read this file. You are not allowed to. So for example, you might want to write some stuff into this file at the beginning of the execution of your program. Then, at a future point in your program you might need to read what you wrote in this file. If you try to read data from this file, you will likely get a NotOpenForReading error as result.\nBut how can you overcome this barrier? How can you create a file that is open to read operations? All you have to do, is to set the read flag to true in the second argument of createFile(). When you set this flag to true, then the file gets create with “read permissions”, and, as consequence, a program like this one below becomes valid:\n\nconst cwd = std.fs.cwd();\nconst file = try cwd.createFile(\n    \"foo.txt\",\n    .{ .read = true }\n);\ndefer file.close();\n\nvar fw = file.writer();\n_ = try fw.writeAll(\"We are going to read this line\\n\");\n\nvar buffer: [300]u8 = undefined;\n@memset(buffer[0..], 0);\ntry file.seekTo(0);\nvar fr = file.reader();\n_ = try fr.readAll(buffer[0..]);\ntry stdout.print(\"{s}\\n\", .{buffer});\n\nWe are going to read this line\nIf you are not familiar with position indicators, you might not recognize the method seekTo(). If that is your case, do not worry, we are going to talk more about this method in Section 13.6. But essentially this method is moving the position indicator back to the beginning of the file, so that we can read the contents of the file from the beginning.\n\n\n13.5.2 Opening files and appending data to it\nOpening files is easy. Just use the openFile() method instead of createFile(). In the first argument of openFile() you provide the path to the file that you want to open. Then, on the second argument you provide the flags (or, the options) that dictates how the file is opened.\nYou can see the full list of options for openFile() by visiting the documentation for OpenFlags9. But the main flag that you will most certainly use is the mode flag. This flag specifies the IO mode that the file will be using when it gets opened. There are three IO modes, or, three values that you can provide to this flag, which are:\n\nread_only, allows only read operations on the file. All write operations are blocked.\nwrite_only, allows only write operations on the file. All read operations are blocked.\nread_write, allows both write and read operations on the file.\n\nThese modes are similar to the modes that you provide to the mode argument of the open() Python built-in function10, or, the mode argument of the fopen() C function11. In the code example below, we are opening the foo.txt text file with a write_only mode, and appending a new line of text to the end of the file. We use seekFromEnd() this time to guarantee that we are going to append the text to the end of the file. Once again, methods such as seekFromEnd() are described in more depth in Section 13.6.\n\nconst cwd = std.fs.cwd();\nconst file = try cwd.openFile(\n    \"foo.txt\", .{ .mode = .write_only }\n);\ndefer file.close();\ntry file.seekFromEnd(0);\nvar fw = file.writer();\n_ = try fw.writeAll(\"Some random text to write\\n\");\n\n\n\n13.5.3 Deleting files\nSometimes, we just need to delete/remove the files that we have. To do that, we use the deleteFile() method. You just provide the path of the file that you want to delete, and this method will try to delete the file located at this path.\n\nconst cwd = std.fs.cwd();\ntry cwd.deleteFile(\"foo.txt\");\n\n\n\n13.5.4 Copying files\nTo copy existing files, we use the copyFile() method. The first argument in this method is the path to the file that you want to copy. The second argument is a Dir object, i.e., a directory handler, more specifically, a Dir object that points to the folder in your computer where you want to copy the file to. The third argument is the new path of the file, or, in other words, the new location of the file. The fourth argument is the options (or flags) to be used in the copy operation.\nThe Dir object that you provide as input to this method will be used to copy the file to the new location. You may create this Dir object before calling the copyFile() method. Maybe you are planning to copy the file to a completely different location in your computer, so it might be worth to create a directory handler to that location. But if you are copying the file to a subfolder of your CWD, then, you can just simply pass the CWD handler to this argument.\n\nconst cwd = std.fs.cwd();\ntry cwd.copyFile(\n    \"foo.txt\",\n    cwd,\n    \"ZigExamples/file-io/foo.txt\",\n    .{}\n);\n\n\n\n13.5.5 Read the docs!\nThere are some other useful methods for file operations available at Dir objects, such as the writeFile() method, but I recommend you to read the docs for the Dir type12 to explore the other available methods, since I already talked too much about them.",
    "crumbs": [
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Filesystem and Input/Output (IO)</span>"
    ]
  },
  {
    "objectID": "Chapters/12-file-op.html#sec-indicators",
    "href": "Chapters/12-file-op.html#sec-indicators",
    "title": "13  Filesystem and Input/Output (IO)",
    "section": "13.6 Position indicators",
    "text": "13.6 Position indicators\nA position indicator is like a type of cursor, or, an index. This “index” identifies the current location in the file (or, in the data stream) that the file descriptor object that you have is currently looking at. When you create a file descriptor, the position indicator starts at the beginning of the file, or, at the beginning of the stream. When you read from or write into the file (or socket, or data stream, etc.) described by this file descriptor object, you end up moving the position indicator.\nIn other words, any IO operation have a common side effect, which is to move the position indicator. For example, suppose that we have a file of 300 bytes total in size. If you read 100 bytes from the file, then, the position indicator moves 100 bytes forward. If you try to write 50 bytes into this same file, these 50 bytes will be written from the current position indicated by the position indicator. Since the indicator is at a 100 bytes forward from the beginning of the file, these 50 bytes would be written in the middle of the file.\nThis is why we have used the seekTo() method at the last code example presented in Section 13.5.1. We have used this method to move the position indicator back to the beginning of the file, which would make sure that we would write the text that we wanted to write from the beginning of the file, instead of writing it from the middle of the file. Because before the write operation, we had performed a read operation, which means that the position indicator was moved in this read operation.\nThe position indicators of a file descriptor object can be changed (or altered) by using the “seek” methods from this file descriptor, which are: seekTo(), seekFromEnd() and seekBy(). These methods have the same effect, or, the same responsibility that the fseek()13 C function.\nConsidering that offset refers to the index that you provide as input to these “seek” methods, the bullet points below summarises what is the effect of each of these methods. As a quick note, in the case of seekFromEnd() and seekBy(), the offset provided can be either a positive or a negative index.\n\nseekTo() will move the position indicator to the location that is offset bytes from the beginning of the file.\nseekFromEnd() will move the position indicator to the location that is offset bytes from the end of the file.\nseekBy() will move the position indicator to the location that is offset bytes from the current position in the file.",
    "crumbs": [
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Filesystem and Input/Output (IO)</span>"
    ]
  },
  {
    "objectID": "Chapters/12-file-op.html#directory-operations",
    "href": "Chapters/12-file-op.html#directory-operations",
    "title": "13  Filesystem and Input/Output (IO)",
    "section": "13.7 Directory operations",
    "text": "13.7 Directory operations\n\n13.7.1 Iterating through the files in a directory\nOne of the most classic tasks related to filesystem is to be able to iterate through the existing files in a directory. To iterate over the files in a directory, we need to create an iterator object.\nYou can produce such iterator object by using either the iterate() or walk() methods of a Dir object. Both methods return an iterator object as output, which you can advance by using the next() method. The difference between these methods, is that iterate() returns a non-recursive iterator, while walk() does. It means that the iterator returned by walk() will not only iterate through the files available in the current directory, but also, through the files from any subdirectory found inside the current directory.\nIn the example below, we are displaying the names of the files stored inside the directory ZigExamples/file-io. Notice that we had to open this directory through the openDir() function. Also notice that we provided the flag iterate in the second argument of openDir(). This flag is important, because without this flag, we would not be allowed to iterate through the files in this directory.\n\nconst cwd = std.fs.cwd();\nconst dir = try cwd.openDir(\n    \"ZigExamples/file-io/\",\n    .{ .iterate = true }\n);\nvar it = dir.iterate();\nwhile (try it.next()) |entry| {\n    try stdout.print(\n        \"File name: {s}\\n\",\n        .{entry.name}\n    );\n}\n\nFile name: create_file_and_write_toit.zig\nFile name: create_file.zig\nFile name: lorem.txt\nFile name: iterate.zig\nFile name: delete_file.zig\nFile name: append_to_file.zig\nFile name: user_input.zig\nFile name: foo.txt\nFile name: create_file_and_read.zig\nFile name: buff_io.zig\nFile name: copy_file.zig\n\n\n13.7.2 Creating new directories\nThere are two methods that are important when it comes to creating directories, which are makeDir() and makePath(). The difference between these two methods is that makeDir() can only create one single directory in the current directory in each call, while makePath() is capable of recursively create subdirectories in the same call.\nThis is why the name of this method is “make path”. It will create as many subdirectories as necessary to create the path that you provided as input. So, if you provide the path \"sub1/sub2/sub3\" as input to this method, it will create three different subdirectories, sub1, sub2 and sub3, within the same function call. In contrast, if you provided such path as input to makeDir(), you would likely get an error as result, since this method can only create a single subdirectory.\n\nconst cwd = std.fs.cwd();\ntry cwd.makeDir(\"src\");\ntry cwd.makePath(\"src/decoders/jpg/\");\n\n\n\n13.7.3 Deleting directories\nTo delete a directory, just provide the path to the directory that you want to delete as input to the deleteDir() method from a Dir object. In the example below, we are deleting the src directory that we have just created in the previous example.\n\nconst cwd = std.fs.cwd();\ntry cwd.deleteDir(\"src\");",
    "crumbs": [
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Filesystem and Input/Output (IO)</span>"
    ]
  },
  {
    "objectID": "Chapters/12-file-op.html#conclusion",
    "href": "Chapters/12-file-op.html#conclusion",
    "title": "13  Filesystem and Input/Output (IO)",
    "section": "13.8 Conclusion",
    "text": "13.8 Conclusion\nIn this chapter, I have described how to perform in Zig the most common filesystem and IO operations. But you might feel the lack of some other, less common, operation in this chapter, such as: how to rename files, or how to open a directory, or how to create symbolic links, or how to use access() to test if a particular path exists in your computer. But for all of these less common tasks, I recommend you to read the documentation of the Dir type14 , since you can find a good description of these cases there.\n\n\n\n\nWikipedia. 2024. “File Descriptor.” Wikipedia. https://en.wikipedia.org/wiki/File_descriptor.",
    "crumbs": [
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Filesystem and Input/Output (IO)</span>"
    ]
  },
  {
    "objectID": "Chapters/12-file-op.html#footnotes",
    "href": "Chapters/12-file-op.html#footnotes",
    "title": "13  Filesystem and Input/Output (IO)",
    "section": "",
    "text": "Previously, these objects were known as the GenericReader and GenericWriter objects. But both of these types were deprecated in 0.15.↩︎\nThe socket objects that we have created in Section 7.4.1, are examples of network sockets.↩︎\nhttps://ziglang.org/documentation/master/std/#std.io.Writer.↩︎\nhttps://ziglang.org/documentation/master/std/#std.io.Reader.↩︎\nhttps://github.com/ziglang/zig/blob/master/lib/std/io/Reader.zig.↩︎\nhttps://github.com/ziglang/zig/blob/master/lib/std/io/Writer.zig.↩︎\nA pipeline is a mechanism for inter-process communication, or, inter-process IO. You could also interpret a pipeline as a “set of processes that are chained together, through the standard input/output devices of the system”. At Linux for example, a pipeline is created inside a terminal, by connecting two or more terminal commands with the “pipe” character (|).↩︎\nhttps://www.lipsum.com/.↩︎\nhttps://ziglang.org/documentation/master/std/#std.fs.File.OpenFlags↩︎\nhttps://docs.python.org/3/tutorial/inputoutput.html#reading-and-writing-files↩︎\nhttps://www.tutorialspoint.com/c_standard_library/c_function_fopen.htm↩︎\nhttps://ziglang.org/documentation/master/std/#std.fs.Dir↩︎\nhttps://en.cppreference.com/w/c/io/fseek↩︎\nhttps://ziglang.org/documentation/master/std/#std.fs.Dir↩︎",
    "crumbs": [
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Filesystem and Input/Output (IO)</span>"
    ]
  },
  {
    "objectID": "Chapters/01-memory.html",
    "href": "Chapters/01-memory.html",
    "title": "3  Memory and Allocators",
    "section": "",
    "text": "3.1 Memory spaces\nIn this chapter, we will talk about memory. How does Zig control memory? What common tools are used? Are there any important aspects that make memory different/special in Zig? You will find the answers here.\nComputers fundamentally rely on memory to function. This memory acts as a temporary storage space for the data and values generated during computations. Without memory, the core concepts of “variables” and “objects” in programming languages would be impossible.\nEvery object that you create in your Zig source code needs to be stored somewhere, in your computer’s memory. Depending on where and how you define your object, Zig will use a different “memory space”, or a different type of memory to store this object.\nEach type of memory normally serves for different purposes. In Zig, there are 3 types of memory (or 3 different memory spaces) that we care about. They are:",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Memory and Allocators</span>"
    ]
  },
  {
    "objectID": "Chapters/01-memory.html#memory-spaces",
    "href": "Chapters/01-memory.html#memory-spaces",
    "title": "3  Memory and Allocators",
    "section": "",
    "text": "Global data register (or the “global data section”);\nStack;\nHeap;\n\n\n3.1.1 Compile-time known versus runtime known\nOne strategy that Zig uses to decide where it will store each object that you declare, is by looking at the value of this particular object. More specifically, by investigating if this value is known at “compile-time” or at “runtime”.\nWhen you write a program in Zig, the values of some of the objects that you write in your program are known at compile time. Meaning that, when you compile your Zig source code, during the compilation process, the zig compiler can figure out the exact value of a particular object that exists in your source code. Knowing the length (or the size) of each object is also important. So the length (or the size) of each object that you write in your program is, in some cases, known at compile time.\nThe zig compiler cares more about knowing the length (or the size) of a particular object , than to know its actual value. But, if the zig compiler knows the value of the object, then, it automatically knows the size of this object. Because it can simply calculate the size of the object by looking at the size of the value.\nTherefore, the priority for the zig compiler is to discover the size of each object in your source code. If the value of the object in question is known at compile-time, then, the zig compiler automatically knows the size/length of this object. But if the value of this object is not known at compile-time, then, the size of this object is only known at compile-time if, and only if, the type of this object has a known fixed size.\nIn order for a type to have a known fixed size, this type must have data members whose size is fixed. If this type includes, for example, a variable sized array in it, then, this type does not have a known fixed size. Because this array can have any size at runtime (i.e., it can be an array of 2 elements, or 50 elements, or 1 thousand elements, etc.).\nFor example, a string object, which internally is an array of constant u8 values ([]const u8) has a variable size. It can be a string object with 100 or 500 characters in it. If we do not know at compile-time, which exact string will be stored inside this string object, then, we cannot calculate the size of this string object at compile-time. So, any type, or any struct declaration that you make, that includes a string data member that does not have an explicit fixed size, makes this type, or this new struct that you are declaring, a type that does not have a known fixed size at compile-time.\nIn contrast, if the type of this struct that you are declaring, includes a data member that is an array, but this array has a known fixed size, like [60]u8 (which declares an array of 60 u8 values), then, this type, or, this struct that you are declaring, becomes a type with a known fixed size at compile-time. And because of that, in this case, the zig compiler does not need to know at compile-time the exact value of any object of this type. Since the compiler can find the necessary size to store this object by looking at the size of its type.\nLet’s look at an example. In the source code below, we have two constant objects (name and array) declared. Because the values of these particular objects are written down, in the source code itself (\"Pedro\" and the number sequence from 1 to 4), the zig compiler can easily discover the values of these constant objects (name and array) during the compilation process. This is what “known at compile time” means. It refers to any object that you have in your Zig source code whose value can be identified at compile time.\n\nfn input_length(input: []const u8) usize {\n    const n = input.len;\n    return n;\n}\n\npub fn main() !void {\n    const name = \"Pedro\";\n    const array = [_]u8{1, 2, 3, 4};\n    _ = name; _ = array;\n}\n\nThe other side of the spectrum are objects whose values are not known at compile time. Function arguments are a classic example of this. Because the value of each function argument depends on the value that you assign to this particular argument, when you call the function.\nFor example, the function input_length() contains an argument named input, which is an array of constant u8 integers ([]const u8). It’s impossible to know the value of this particular argument at compile time. And it also is impossible to know the size/length of this particular argument. Because it’s an array that does not have a fixed size specified explicitly in the argument type annotation.\nSo, we know that this input argument will be an array of u8 integers. But we do not know at compile-time, its value, and neither its size. This information is known only at runtime, which is the period of time when you program is executed. As a consequence, the value of the expression input.len is also known only at runtime. This is an intrinsic characteristic of any function. Just remember that the value of function arguments is usually not “compile-time known”.\nHowever, as I mentioned earlier, what really matters to the compiler is to know the size of the object at compile-time, and not necessarily its value. So, although we don’t know the value of the object n, which is the result of the expression input.len, at compile-time, we do know its size. Because the expression input.len always returns a value of type usize, and the type usize has a known fixed size.\n\n\n3.1.2 Global data register\nThe global data register is a specific section of the executable of your Zig program, that is responsible for storing any value that is known at compile time.\nEvery constant object whose value is known at compile time that you declare in your source code, is stored in the global data register. Also, every literal value that you write in your source code, such as the string \"this is a string\", or the integer 10, or a boolean value such as true, is also stored in the global data register.\nHonestly, you don’t need to care much about this memory space. Because you can’t control it, you can’t deliberately access it or use it for your own purposes. Also, this memory space does not affect the logic of your program. It simply exists in your program.\n\n\n3.1.3 Stack vs Heap\nIf you are familiar with systems programming, or just low-level programming in general, you probably have heard of the “duel” between Stack vs Heap. These are two different types of memory, or different memory spaces, which are both available in Zig.\nThese two types of memory don’t actually duel with each other. This is a common mistake that beginners have, when seeing “x vs y” styles of tabloid headlines. These two types of memory are actually complementary to each other. So, in almost every Zig program that you ever write, you will likely use a combination of both. I will describe each memory space in detail over the next sections. But for now, I just want to stablish the main difference between these two types of memory.\nIn essence, the stack memory is normally used to store values whose length is fixed and known at compile time. In contrast, the heap memory is a dynamic type of memory space, meaning that, it’s used to store values whose length might grow during the execution (runtime) of your program (Chen and Guo 2022).\nLengths that grow during runtime are intrinsically associated with “runtime known” type of values. In other words, if you have an object whose length might grow during runtime, then, the length of this object becomes not known at compile time. If the length is not known at compile-time, the value of this object also becomes not known at compile-time. These types of objects should be stored in the heap memory space, which is a dynamic memory space, which can grow or shrink to fit the size of your objects.\n\n\n3.1.4 Stack\nThe stack is a type of memory that uses the power of the stack data structure, hence the name. A “stack” is a type of data structure that uses a “last in, first out” (LIFO) mechanism to store the values you give it to. I imagine you are familiar with this data structure. But, if you are not, the Wikipedia page1 , or, the Geeks For Geeks page2 are both excellent and easy resources to fully understand how this data structure works.\nSo, the stack memory space is a type of memory that stores values using a stack data structure. It adds and removes values from the memory by following a “last in, first out” (LIFO) principle.\nEvery time you make a function call in Zig, an amount of space in the stack is reserved for this particular function call (Chen and Guo 2022; Zig Software Foundation 2024). The value of each function argument given to the function in this function call is stored in this stack space. Also, every local object that you declare inside the function scope is usually stored in this same stack space.\nLooking at the example below, the object result is a local object declared inside the scope of the add() function. Because of that, this object is stored inside the stack space reserved for the add() function. The r object (which is declared outside of the add() function scope) is also stored in the stack. But since it’s declared in the “outer” scope, this object is stored in the stack space that belongs to this outer scope.\n\nfn add(x: u8, y: u8) u8 {\n    const result = x + y;\n    return result;\n}\n\npub fn main() !void {\n    const r = add(5, 27);\n    _ = r;\n}\n\nSo, any object that you declare inside the scope of a function is always stored inside the space that was reserved for that particular function in the stack memory. This also counts for any object declared inside the scope of your main() function for example. As you would expect, in this case, they are stored inside the stack space reserved for the main() function.\nOne very important detail about the stack memory is that it frees itself automatically. This is very important, remember that. When objects are stored in the stack memory, you don’t have the work (or the responsibility) of freeing/destroying these objects. Because they will be automatically destroyed once the stack space is freed at the end of the function scope.\nSo, once the function call returns (or ends, if you prefer to call it this way) the space that was reserved in the stack is destroyed, and all of the objects that were in that space goes away with it. This mechanism exists because this space, and the objects within it, are not necessary anymore, since the function “finished its business”. Using the add() function that we exposed above as an example, it means that the object result is automatically destroyed once the function returns.\n\n\n\n\n\n\nImportant\n\n\n\nLocal objects that are stored in the stack space of a function are automatically freed/destroyed at the end of the function scope.\n\n\nThis same logic applies to any other special structure in Zig that has its own scope by surrounding it with curly braces ({}). For loops, while loops, if else statements, etc. For example, if you declare any local object in the scope of a for loop, this local object is accessible only within the scope of this particular for loop. Because once the scope of this for loop ends, the space in the stack reserved for this for loop is freed. The example below demonstrates this idea.\n\n// This does not compile successfully!\nconst a = [_]u8{0, 1, 2, 3, 4};\nfor (0..a.len) |i| {\n    const index = i;\n    _ = index;\n}\n// Trying to use an object that was\n// declared in the for loop scope,\n// and that does not exist anymore.\nstd.debug.print(\"{d}\\n\", .{index});\n\nOne important consequence of this mechanism is that, once the function returns, you can no longer access any memory address that was inside the space in the stack reserved for this particular function. Because this space was destroyed. This means that, if this local object is stored in the stack, you cannot make a function that returns a pointer to this object.\nThink about that for a second. If all local objects in the stack are destroyed at the end of the function scope, why would you even consider returning a pointer to one of these objects? This pointer is at best, invalid, or, more likely, “undefined”.\nIn conclusion, it’s totally fine to write a function that returns the local object itself as result, because then, you return the value of that object as the result. But, if this local object is stored in the stack, you should never write a function that returns a pointer to this local object. Because the memory address pointed by the pointer no longer exists.\nSo, using again the add() function as an example, if you rewrite this function so that it returns a pointer to the local object result, the zig compiler will actually compile your program, with no warnings or errors. At first glance, it looks like this is good code that works as expected. But this is a lie!\nIf you try to take a look at the value inside of the r object, or, if you try to use this r object in another expression or function call, then, you would have undefined behaviour, and major bugs in your program (Zig Software Foundation 2024, see “Lifetime and Ownership”3 and “Undefined Behaviour”4 sections).\n\nfn add(x: u8, y: u8) *const u8 {\n    const result = x + y;\n    return &result;\n}\n\npub fn main() !void {\n    // This code compiles successfully. But it has\n    // undefined behaviour. Never do this!!!\n    // The `r` object is undefined!\n    const r = add(5, 27); _ = r;\n}\n\nThis “invalid pointer to stack variable” problem is well known across many programming language communities. If you try to do the same thing, for example, in a C or C++ program (i.e., returning an address to a local object stored in the stack), you would also get undefined behaviour in the program.\n\n\n\n\n\n\nImportant\n\n\n\nIf a local object in your function is stored in the stack, you should never return a pointer to this local object from the function. Because this pointer will always become undefined after the function returns, since the stack space of the function is destroyed at the end of its scope.\n\n\nBut what if you really need to use this local object in some way after your function returns? How can you do this? The answer is: “in the same way you would do if this were a C or C++ program. By returning an address to an object stored in the heap”. The heap memory has a much more flexible lifecycle, and allows you to get a valid pointer to a local object of a function that already returned from its scope.\n\n\n3.1.5 Heap\nOne important limitation of the stack, is that, only objects whose length/size is known at compile-time can be stored in it. In contrast, the heap is a much more dynamic (and flexible) type of memory. It’s the perfect type of memory to use for objects whose size/length might grow during the execution of your program.\nVirtually any application that behaves as a server is a classic use case of the heap. A HTTP server, a SSH server, a DNS server, a LSP server, … any type of server. In summary, a server is a type of application that runs for long periods of time, and that serves (or “deals with”) any incoming request that reaches this particular server.\nThe heap is a good choice for this type of system, mainly because the server does not know upfront how many requests it will receive from users, while it is active. It could be a single request, 5 thousand requests, or even zero requests. The server needs to have the ability to allocate and manage its memory according to how many requests it receives.\nAnother key difference between the stack and the heap, is that the heap is a type of memory that you, the programmer, have complete control over. This makes the heap a more flexible type of memory, but it also makes it harder to work with. Because you, the programmer, is responsible for managing everything related to it. Including where the memory is allocated, how much memory is allocated, and where this memory is freed.\n\nUnlike stack memory, heap memory is allocated explicitly by programmers and it won’t be deallocated until it is explicitly freed (Chen and Guo 2022).\n\nTo store an object in the heap, you, the programmer, needs to explicitly tells Zig to do so, by using an allocator to allocate some space in the heap. In Section 3.3, I will present how you can use allocators to allocate memory in Zig.\n\n\n\n\n\n\nImportant\n\n\n\nEvery memory you allocate in the heap needs to be explicitly freed by you, the programmer.\n\n\nThe majority of allocators in Zig do allocate memory on the heap. But some exceptions to this rule are ArenaAllocator() and FixedBufferAllocator(). The ArenaAllocator() is a special type of allocator that works in conjunction with a second type of allocator. On the other side, the FixedBufferAllocator() is an allocator that works based on buffer objects created on the stack. This means that the FixedBufferAllocator() makes allocations only on the stack.\n\n\n3.1.6 Summary\nAfter discussing all of these boring details, we can quickly recap what we learned. In summary, the Zig compiler will use the following rules to decide where each object you declare is stored:\n\nevery literal value (such as \"this is string\", 10, or true) is stored in the global data section.\nevery constant object (const) whose value is known at compile-time is also stored in the global data section.\nevery object (constant or not) whose length/size is known at compile time is stored in the stack space for the current scope.\nif an object is created with the method alloc() or create() of an allocator object, this object is stored in the memory space used by this particular allocator object. Most of allocators available in Zig use the heap memory, so, this object is likely stored in the heap (FixedBufferAllocator() is an exception to that).\nthe heap can only be accessed through allocators. If your object was not created through the alloc() or create() methods of an allocator object, then, it is most certainly not an object stored in the heap.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Memory and Allocators</span>"
    ]
  },
  {
    "objectID": "Chapters/01-memory.html#sec-stack-overflow",
    "href": "Chapters/01-memory.html#sec-stack-overflow",
    "title": "3  Memory and Allocators",
    "section": "3.2 Stack overflows",
    "text": "3.2 Stack overflows\nAllocating memory on the stack is generally faster than allocating it on the heap. But this better performance comes with many restrictions. We have already discussed many of these restrictions of the stack in Section 3.1.4. But there is one more important limitation that I want to talk about, which is the size of the stack itself.\nThe stack is limited in size. This size varies from computer to computer, and it depends on a lot of things (the computer architecture, the operating system, etc.). Nevertheless, this size is usually not that big. This is why we normally use the stack to store only temporary and small objects in memory.\nIn essence, if you try to make an allocation on the stack, that is so big that exceeds the stack size limit, a stack overflow happens, and your program just crashes as a result of that. In other words, a stack overflow happens when you attempt to use more space than is available on the stack.\nThis type of problem is very similar to a buffer overflow, i.e., you are trying to use more space than is available in the “buffer object”. However, a stack overflow always causes your program to crash, while a buffer overflow does not always cause your program to crash (although it often does).\nYou can see an example of a stack overflow in the example below. We are trying to allocate a very big array of u64 values on the stack. You can see below that this program does not run successfully, because it crashed with a “segmentation fault” error message.\n\nvar very_big_alloc: [1000 * 1000 * 24]u64 = undefined;\n@memset(very_big_alloc[0..], 0);\n\nSegmentation fault (core dumped)\nThis segmentation fault error is a result of the stack overflow that was caused by the big memory allocation made on the stack, to store the very_big_alloc object. This is why very big objects are usually stored on the heap, instead of the stack.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Memory and Allocators</span>"
    ]
  },
  {
    "objectID": "Chapters/01-memory.html#sec-allocators",
    "href": "Chapters/01-memory.html#sec-allocators",
    "title": "3  Memory and Allocators",
    "section": "3.3 Allocators",
    "text": "3.3 Allocators\nOne key aspect about Zig, is that there are “no hidden-memory allocations” in Zig. What that really means, is that “no allocations happen behind your back in the standard library” (Sobeston 2024).\nThis is a known problem, especially in C++. Because in C++, there are some operators that do allocate memory behind the scene, and there is no way for you to know that, until you actually read the source code of these operators, and find the memory allocation calls. Many programmers find this behaviour annoying and hard to keep track of.\nBut, in Zig, if a function, an operator, or anything from the standard library needs to allocate some memory during its execution, then, this function/operator needs to receive (as input) an allocator provided by the user, to actually be able to allocate the memory it needs.\nThis creates a clear distinction between functions that “do not” from those that “actually do” allocate memory. Just look at the arguments of this function. If a function, or operator, has an allocator object as one of its inputs/arguments, then, you know for sure that this function/operator will allocate some memory during its execution.\nAn example is the allocPrint() function from the Zig Standard Library. With this function, you can write a new string using format specifiers. So, this function is, for example, very similar to the function sprintf() in C. In order to write such a new string, the allocPrint() function needs to allocate some memory to store the output string.\nThat is why, the first argument of this function is an allocator object that you, the user/programmer, gives as input to the function. In the example below, I am using the GeneralPurposeAllocator() as my allocator object. But I could easily use any other type of allocator object from the Zig Standard Library.\n\nvar gpa = std.heap.GeneralPurposeAllocator(.{}){};\nconst allocator = gpa.allocator();\nconst name = \"Pedro\";\nconst output = try std.fmt.allocPrint(\n    allocator,\n    \"Hello {s}!!!\",\n    .{name}\n);\ntry stdout.print(\"{s}\\n\", .{output});\ntry stdout.flush();\n\nHello Pedro!!!\n\n\nYou get a lot of control over where and how much memory this function can allocate. Because it is you, the user/programmer, that provides the allocator for the function to use. This makes “total control” over memory management easier to achieve in Zig.\n\n3.3.1 What are allocators?\nAllocators in Zig are objects that you can use to allocate memory for your program. They are similar to the memory allocating functions in C, like malloc() and calloc(). So, if you need to use more memory than you initially have, during the execution of your program, you can simply ask for more memory by using an allocator object.\nZig offers different types of allocators, and they are usually available through the std.heap module of the standard library. Thus, just import the Zig Standard Library into your Zig module (with @import(\"std\")), and you can start using these allocators in your code.\nFurthermore, every allocator object is built on top of the Allocator interface in Zig. This means that, every allocator object you find in Zig must have the methods alloc(), create(), free() and destroy(). So, you can change the type of allocator you are using, but you don’t need to change the function calls to the methods that do the memory allocation (and the free memory operations) for your program.\n\n\n3.3.2 Why you need an allocator?\nAs we described in Section 3.1.4, everytime you make a function call in Zig, a space in the stack is reserved for this function call. But the stack has a key limitation which is: every object stored in the stack has a known fixed length.\nBut in reality, there are two very common instances where this “fixed length limitation” of the stack is a deal braker:\n\nthe objects that you create inside your function might grow in size during the execution of the function.\nsometimes, it’s impossible to know upfront how many inputs you will receive, or how big this input will be.\n\nAlso, there is another instance where you might want to use an allocator, which is when you want to write a function that returns a pointer to a local object. As I described in Section 3.1.4, you cannot do that if this local object is stored in the stack. However, if this object is stored in the heap, then, you can return a pointer to this object at the end of the function. Because you (the programmer) control the lifetime of any heap memory that you allocate. You decide when this memory gets destroyed/freed.\nThese are common situations for which the stack is not good. That is why you need a different memory management strategy to store these objects inside your function. You need to use a memory type that can grow together with your objects, or that you can control the lifetime of this memory. The heap fits this description.\nAllocating memory on the heap is commonly known as dynamic memory management. As the objects you create grow in size during the execution of your program, you grow the amount of memory you have by allocating more memory in the heap to store these objects. And you do that in Zig, by using an allocator object.\n\n\n3.3.3 The different types of allocators\nAt the moment of the writing of this book, in Zig, we have 6 different allocators available in the standard library:\n\nGeneralPurposeAllocator().\npage_allocator().\nFixedBufferAllocator() and ThreadSafeFixedBufferAllocator().\nArenaAllocator().\nc_allocator() (requires you to link to libc).\n\nEach allocator has its own perks and limitations. All allocators, except FixedBufferAllocator() and ArenaAllocator(), are allocators that use the heap memory. So any memory that you allocate with these allocators, will be placed in the heap.\n\n\n3.3.4 General-purpose allocators\nThe GeneralPurposeAllocator(), as the name suggests, is a “general purpose” allocator. You can use it for every type of task. In the example below, I’m allocating enough space to store a single integer in the object some_number.\n\nconst std = @import(\"std\");\n\npub fn main() !void {\n    var gpa = std.heap.GeneralPurposeAllocator(.{}){};\n    const allocator = gpa.allocator();\n    const some_number = try allocator.create(u32);\n    defer allocator.destroy(some_number);\n\n    some_number.* = @as(u32, 45);\n}\n\nWhile useful, you might want to use the c_allocator(), which is a alias to the C standard allocator malloc(). So, yes, you can use malloc() in Zig if you want to. Just use the c_allocator() from the Zig standard library. However, if you do use c_allocator(), you must link to Libc when compiling your source code with the zig compiler, by including the flag -lc in your compilation process. If you do not link your source code to Libc, Zig will not be able to find the malloc() implementation in your system.\n\n\n3.3.5 Page allocator\nThe page_allocator() is an allocator that allocates full pages of memory in the heap. In other words, every time you allocate memory with page_allocator(), a full page of memory in the heap is allocated, instead of just a small piece of it.\nThe size of this page depends on the system you are using. Most systems use a page size of 4KB in the heap, so, that is the amount of memory that is normally allocated in each call by page_allocator(). That is why, page_allocator() is considered a fast, but also “wasteful” allocator in Zig. Because it allocates a big amount of memory in each call, and you most likely will not need that much memory in your program.\n\n\n3.3.6 Buffer allocators\nThe FixedBufferAllocator() and ThreadSafeFixedBufferAllocator() are allocator objects that work with a fixed sized buffer object at the back. In other words, they use a fixed sized buffer object as the basis for the memory. When you ask these allocator objects to allocate some memory for you, they are essentially reserving some amount of space inside this fixed sized buffer object for you to use.\nThis means that, in order to use these allocators, you must first create a buffer object in your code, and then, give this buffer object as an input to these allocators.\nThis also means that, these allocator objects can allocate memory both in the stack or in the heap. Everything depends on where the buffer object that you provide lives. If this buffer object lives in the stack, then, the memory allocated is “stack-based”. But if it lives on the heap, then, the memory allocated is “heap-based”.\nIn the example below, I’m creating a buffer object on the stack that is 10 elements long. Notice that I give this buffer object to the FixedBufferAllocator() constructor. Now, because this buffer object is 10 elements long, this means that I am limited to this space. I cannot allocate more than 10 elements with this allocator object. If I try to allocate more than that, the alloc() method will return an OutOfMemory error value.\n\nvar buffer: [10]u8 = undefined;\nfor (0..buffer.len) |i| {\n    buffer[i] = 0; // Initialize to zero\n}\n\nvar fba = std.heap.FixedBufferAllocator.init(&buffer);\nconst allocator = fba.allocator();\nconst input = try allocator.alloc(u8, 5);\ndefer allocator.free(input);\n\nRemember, the memory allocated by these allocator objects can be either from the stack, or, from the heap. It all depends on where the buffer object that you provide lives. In the above example, the buffer object lives in the stack, and, therefore, the memory allocated is based in the stack. But what if it was based on the heap?\nAs we described in Section 3.2, one of the main reasons why you would use the heap, instead of the stack, is to allocate huge amounts of space to store very big objects. Thus, let’s suppose you wanted to use a very big buffer object as the basis for your allocator objects. You would have to allocate this very big buffer object on the heap. The example below demonstrates this case.\n\nconst heap = std.heap.page_allocator;\nconst memory_buffer = try heap.alloc(\n    u8, 100 * 1024 * 1024 // 100 MB memory\n);\ndefer heap.free(memory_buffer);\nvar fba = std.heap.FixedBufferAllocator.init(\n    memory_buffer\n);\nconst allocator = fba.allocator();\n\nconst input = try allocator.alloc(u8, 1000);\ndefer allocator.free(input);\n\n\n\n3.3.7 Arena allocator\nThe ArenaAllocator() is an allocator object that takes a child allocator as input. The idea behind the ArenaAllocator() in Zig is similar to the concept of “arenas” in the programming language Go5. It’s an allocator object that allows you to allocate memory as many times you want, but free all memory only once. In other words, if you have, for example, called 5 times the method alloc() of an ArenaAllocator() object, you can free all the memory you allocated over these 5 calls at once, by simply calling the deinit() method of the same ArenaAllocator() object.\nIf you give, for example, a GeneralPurposeAllocator() object as input to the ArenaAllocator() constructor, like in the example below, then, the allocations you perform with alloc() will actually be made with the underlying object GeneralPurposeAllocator() that was passed. So, with an arena allocator, any new memory you ask for is allocated by the child allocator. The only thing that an arena allocator really does is help you to free all the memory you allocated multiple times with just a single command. In the example below, I called alloc() 3 times. So, if I did not use an arena allocator, then, I would need to call free() 3 times to free all the allocated memory.\n\nvar gpa = std.heap.GeneralPurposeAllocator(.{}){};\nvar aa = std.heap.ArenaAllocator.init(gpa.allocator());\ndefer aa.deinit();\nconst allocator = aa.allocator();\n\nconst in1 = try allocator.alloc(u8, 5);\nconst in2 = try allocator.alloc(u8, 10);\nconst in3 = try allocator.alloc(u8, 15);\n_ = in1; _ = in2; _ = in3;\n\n\n\n3.3.8 The alloc() and free() methods\nIn the code example below, we are accessing the stdin, which is the standard input channel, to receive an input from the user. We read the input given by the user with the readSliceAll() method.\nNow, after reading the input of the user, we need to store this input somewhere in our program. That is why I use an allocator in this example. I use it to allocate some amount of memory to store this input given by the user. More specifically, the method alloc() of the allocator object is used to allocate an array capable of storing 50 u8 values.\nNotice that this alloc() method receives two inputs. The first one, is a type. This defines what type of values the allocated array will store. In the example below, we are allocating an array of unsigned 8-bit integers (u8). But you can create an array to store any type of value you want. Next, in the second argument, we define the size of the allocated array, by specifying how many elements this array will contain. In the case below, we are allocating an array of 50 elements.\nIn Section 1.8 we described that strings in Zig are simply arrays of characters. Each character is represented by a u8 value6. So, this means that the array that was allocated in the object input is capable of storing a string that is 50-characters long.\nSo, in essence, the expression var input: [50]u8 = undefined would create an array for 50 u8 values in the stack of the current scope. But, you can allocate the same array in the heap by using the expression var input = try allocator.alloc(u8, 50).\n\nconst std = @import(\"std\");\nvar stdin_buffer: [1024]u8 = undefined;\nvar stdout_buffer: [1024]u8 = undefined;\nvar stdout_writer = std.fs.File.stdout().writer(&stdout_buffer);\nvar stdin_reader = std.fs.File.stdin().reader(&stdin_buffer);\nconst stdout = &stdout_writer.interface;\nconst stdin = &stdin_reader.interface;\n\npub fn main() !void {\n    var gpa = std.heap.GeneralPurposeAllocator(.{}){};\n    const allocator = gpa.allocator();\n    var input = try allocator.alloc(u8, 50);\n    defer allocator.free(input);\n    @memset(input[0..], 0);\n\n    // read user input\n    stdin.readSliceAll(input[0..]) catch |err| switch(err) {\n        // Reached end of input, do nothing else\n        error.EndOfStream =&gt; {},\n        else =&gt; return err,\n    };\n    try stdout.print(\"{s}\\n\", .{input});\n    try stdout.flush();\n}\n\nAlso, notice that in this example, we use the defer keyword (which I described in Section 2.1.3) to run a small piece of code at the end of the current scope, which is the expression allocator.free(input). When you execute this expression, the allocator will free the memory that it allocated for the input object.\nWe have talked about this in Section 3.1.5. You should always explicitly free any memory that you allocate using an allocator! You do that by using the free() method of the same allocator object you used to allocate this memory. The defer keyword is used in this example only to help us execute this free operation at the end of the current scope.\n\n\n3.3.9 The create() and destroy() methods\nWith the alloc() and free() methods, you can allocate memory to store multiple elements at once. In other words, with these methods, we always allocate an array to store multiple elements at once. But what if you need enough space to store just a single item? Should you allocate an array of a single element through alloc()?\nThe answer is no! In this case, you should use the create() method of the allocator object. Every allocator object offers the create() and destroy() methods, which are used to allocate and free memory for a single item, respectively.\nSo, in essence, if you want to allocate memory to store an array of elements, you should use alloc() and free(). But if you need to store just a single item, then, the create() and destroy() methods are ideal for you.\nIn the example below, I’m defining a struct to represent an user of some sort. It could be a user for a game, or software to manage resources, it doesn’t matter. Notice that I use the create() method this time, to store a single User object in the program. Also notice that I use the destroy() method to free the memory used by this object at the end of the scope.\n\nconst std = @import(\"std\");\nconst User = struct {\n    id: usize,\n    name: []const u8,\n\n    pub fn init(id: usize, name: []const u8) User {\n        return .{ .id = id, .name = name };\n    }\n};\n\npub fn main() !void {\n    var gpa = std.heap.GeneralPurposeAllocator(.{}){};\n    const allocator = gpa.allocator();\n    const user = try allocator.create(User);\n    defer allocator.destroy(user);\n\n    user.* = User.init(0, \"Pedro\");\n}\n\n\n\n\n\nChen, Jenny, and Ruohao Guo. 2022. “Stack and Heap Memory.” Introduction to Data Structures and Algorithms with C++. https://courses.engr.illinois.edu/cs225/fa2022/resources/stack-heap/.\n\n\nSobeston. 2024. “Zig Guide.” https://zig.guide/.\n\n\nZig Software Foundation. 2024. “Language Reference.” Zig Software Foundation. https://ziglang.org/documentation/master/.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Memory and Allocators</span>"
    ]
  },
  {
    "objectID": "Chapters/01-memory.html#footnotes",
    "href": "Chapters/01-memory.html#footnotes",
    "title": "3  Memory and Allocators",
    "section": "",
    "text": "https://en.wikipedia.org/wiki/Stack_(abstract_data_type)↩︎\nhttps://www.geeksforgeeks.org/stack-data-structure/↩︎\nhttps://ziglang.org/documentation/master/#Lifetime-and-Ownership↩︎\nhttps://ziglang.org/documentation/master/#Undefined-Behavior↩︎\nhttps://go.dev/src/arena/arena.go↩︎\nJust remember that this is an oversimplification. If we are talking only about ASCII strings, then yes, every u8 value represents a separate character in the string. But if we enter the realm of UTF-8 encoded string, then, this scenario is not always true.↩︎",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Memory and Allocators</span>"
    ]
  }
]